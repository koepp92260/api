= Installation and Startup

=== I keep getting 'unknown adapter' exceptions when I run any of the scripts

If you see something like:

  /usr/lib/ruby/gems/1.8/gems/activerecord-1.13.2/lib/active_record/
  connection_adapters/abstract/connection_specification.rb:79:in
  `establish_connection': database configuration specifies nonexistent
  kirbybase adapter (ActiveRecord::AdapterNotFound)

You need to require 'kirbybase_adpater' *before* or *in* the +Rails::Initializer.run+
section of the config/environment.rb file of your project.

=== What do I set in database.yml?

The simplest thing is to specify just the adapter and the DB path:

  development:
    adapter: kirbybase
    database: db/dev

The +database+ parameter should point to a directory in which KirbyBase will
store the .tbl files. There are a few other parameters which will be passed to
the +KirbyBase.new+ method, but these are untested.

= Usage

=== How do I use code blocks?

You can specify Ruby code blocks instead of SQL fragments to the +find+ method
(and +count+, +delete_all+ and +update_all+ methods) like so:
  Book.find :all, :conditions => lambda{|rec| rec.title =~ /ruby/i}

Things to watch out for:
* The code is run against the KirbyBase row (struct) and not against the Rails
  ActiveRecord::Base object.
* If you want to do multi-db development you have to wrap this with the 
  appropriate checks (+ActiveRecord::Base.connection.adapter_name == 'KirbyBase'+).

=== Is there a big difference between code blocks and translating SQL fragments?

We haven't tested relative performance. These are the considerations for each
approach:

==== Code Blocks
* Are more Rubyish
* Are always correct
* SQL's LIKE operator isn't supported, so you'd have to use blocks and regexps
* They don't play as nice with multi-dbs
* Are run against the KirbyBase row (struct), not the ActiveRecord object

==== SQL Fragments
* Are a better fir for Rails
* Are easier to handle in multi-db projects (no ugly +if+s)
* Are translated, and there's always a chance of something getting missed
* Don't support SQL's LIKE operator

=== Are there more online places I can read about Ackbar/KirbyBase on Rails?

Sure. 

==== Official sites with docos: 
Ackbar: http://ackbar.rubyforge.org

KirbyBase: http://netpromi.com/kirbybase_ruby.html

==== Blogs:
Assaph's blog: http://www.bloglines.com/blog/AssaphMehr

Jamey's Blog: http://houseonfire.wordpress.com

==== Sample projects:
Jamey's blog has a run of the Depot sample app from Agile Web Development with 
Rails. Pimki (http://pimki.rubyforge.org) is currently undergoing extreme
makeover to run on both KirbyBase and SQLite.

= Multi Database Development

=== Can I use KirbyBase for some tables and an SQL dbms for others?

No. To work with KB, the adapter overrides certain methods
in ActiveRecords::Base and the various Associations to bypass SQL generation.
These make it not work with other databases.

=== Where do I start?

You should make sure you require +kirbybase_adapter+ *only if using KirbyBase*.
This is important because of the reasons stated above. You should require the 
adapter when you know it's going to be used, but before the +establish_connection+
call, i.e. *inside* the +Rails::Initializer.run+ call. You should also create
a different +database.yml+ file. For example:

  if ENV['SQLITE3']
    config.database_configuration_file = 'config/sqlite3_db.yml'
  else
    config.database_configuration_file = 'config/kirbybase_db.yml'
    require 'kirbybase_adapter'
  end

=== What's the comparable method to MySQL's +now+ / Oracle's +sysdate+ calls?

Use +Time.now+ or +Date.today+. For example, change:
   :conditions => "date_available <= now()"
to:
   :conditions => "date_available <= Time.now"

=== I want to support multiple databases, how do I still do the above?

Define a +now+ method for +Object+:

  class Object
    def now() Time.now() end
  end

Now, depending on who is evaluating the conditions (MySQL or KirbyBase),
different functions will be called... but give the same results.
